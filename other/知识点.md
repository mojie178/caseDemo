# 知识点
## HTTPS 握手过程
1. 客户端使用HTTPS点URL访问WEB服务器，要求与服务器建立SSL连接
2. WEB服务器收到客户端请求后，会将网站点证书（包含公钥）传送一份给客户端
3. 客户端收到网站证书后会检查证书的颁发机构以及过期时间，如果没有问题就随机产生一个密钥
4. 客户端利用公钥将会话密钥加密，并传送给服务端利用自己的私钥解密出会话密钥
5. 之后服务器与客户端使用密钥加密传输

## TCP
> TCP/IP协议按层次分别为四层：应用层、传输层、网络层和数据链路层

### 三次握手
> 三次握手为了防止已失效对连接请求报文段突然又传到服务端，因为产生错误
1. 发送端标有SYN标志的数据包发送到接收端
2. 发送端收到数据包并发出标有SYN/ACK的数据包
3. 发送端发出标有ACK的数据包

## 四次挥手
> TCP是全双工模式，当Client发出Fin报文时，只是表示Client已经没有数据要发送了，Client告诉server，它的数据已经全部发送完毕了。但是，这个时候Client还是可以接收server的数据，当server返回ACK报文段时，表示它已知道Client没有数据发送了，但server还是可以发送数据到Client的，当server也发送了FIN报文段时，这个时候表示server也没有数据要发送了，就通知Client，如果收到Client确认报文段，之后彼此就会中断这次TCP连接。
1. 主动方发送Fin+ACK报文，并置发送序号为X
2. 被动方发送ACK报文，并置发送序号为Z，在确认序号为X+1
3. 被动方发送Fin+ACK报文，并置发送序号为Y，在确认序号为X
4. 主动发送ACK报文并置发序号为X，在确认序号为Y

## HTTP VS HTTPS
HTTP特点：
+ 协议对客户端没有状态存储，对事物处理没有“记忆”能力
+ 无连接：由于无状态特点，每次请求需求通过TCP三次握手四次挥手，和服务器重新建立连接
+ 基于请求和响应：基本对特性，由客户端发起请求，服务端响应
+ 简单快速、灵活
+ 通信使用明文、请求和响应不会对通信方进行确认，无法保护数据对完整性

HTTPS特点：
> 基于HTTP协议，通过SSL或TLS提供加密处理数据验证对方身份以及数据完整性保护
+ 内容加密：采用混合加密技术，中间者无法直接查看明文内容
+ 验证身份：通过证书认证客户端访问对是自己对服务器
+ 保护老数据完整性：防止传输对内容被中间人冒充或者篡改

## WEBSOCKET
+ 建立在TCP协议之上，服务器端的实现比较容易
+ 与HTTP协议有着良好的兼容性
+ 数据格式比较轻重，性能开销小，通信高效
+ 可以发送文本，也可以发送二进制数据
+ 没有同源限制，客户端可以与任意服务器通信
+ 协议标识符WS（如果加密，则为WSS），服务器网址就是URL

## 通信数据转发程序：代理、网关、隧道
1. 代理：一种有转发功能的应用程序，它扮演位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端
2. 网关：转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理
3. 隧道：在相隔甚远对客户端和服务器两者之间进行中转，并保持双方通信连接对应用程序

## GET VS POST
+ GET把请求对数据放在URL上，即HTTP协议上；POST把数据放在HTTP的包体内
+ GET提交的数据最大是2K（原则上URL没有限制，此限制由于浏览器）；POST理论上没有限制
+ GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；POST会发出两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 OK（返回数据）
+ GET在浏览器回退时是无害的，POST会再次提交请求
+ GET产生的URL地址可以被Bookmark，而POST不可以
+ GET请求会被浏览器主动cache，而POST不会，除非手动设置
+ GET请求只能进行URL编码，而POST支持多种编码方式
+ GET请求参数会被完整保留在历史记录，而POST不会
+ GET只接收ASCII字符的参数的数据类型，而POST没有限制
+ GET比POST高效

## 箭头函数
+ 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
+ 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误
+ 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替
+ 不可以使用yield命令，用此箭头函数不能用作Generator函数

## 闭包
闭包产生的必要条件：
1. 存在函数嵌套
2. 嵌套的内部函数必须引用在外部函数中定义的变量
3. 嵌套的内部函数必须被执行

闭包的优点：
1. 变量常驻内存，对于实现某些业务很有帮助，比如计数器
2. 架起一座桥梁，让函数外部访问函数内部变量成为可能
3. 私有化，一定程度上解决命名冲突问题，可以实现私有变量

闭包的缺点：
1. 存在这样可能，变量常驻内存中，其占用内存无法被GC回收，导致内存溢出

## webpack热更新原理
1. 当修改了一个或多个文件
2. 文件系统接收更改并通知webpack
3. webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新
4. HMR Server使用webSocket通知HMR runtime需要更新，HMR运行时通过HTTP请求更新jsonp
5. HMR运行时替换更新中当模块，如果确定这些模块无法更新，则触发整个页面刷新

## 虚拟DOM
虚拟DOM相当于在JS和真实DOM中间加了一个缓存，利用dom diff算法避免了没有必要当DOM操作，从而提高性能

VUE通过Object.defineProperty劫持传进来的数据，然后在数据getter的时候订阅重新编译模版的消息，然后通过JS监听元素的事件，将新的值重新赋值给被劫持的data，这样就会触发setter函数，再setter函数中就会去发布重新编译模版的消息

## NEW操作符
+ 创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型
+ 属性和方法被加入到this引用的对象中
+ 新创建的对象由this所引用，并且最后隐式的返回this

## 一个页面从输入URL到页面加载显示完成，都发生什么
1. 当发送一个URL请求时，不管这个URL是WEB页面当URL还是WEB页面上每个资源当URL，浏览器都会开启一个线程处理这个请求，同时在远程DNS服务器上启动一个DNS查询，这能使浏览器获得请求对应都IP地址
2. 浏览器与服务器三次握手后建立一个TCP/IP连接
3. 一旦TCP/IP连接建立，浏览器会向服务器发送请求，远程服务器找到资源并返回
4. 此时，服务器提供资源服务，客户端开始下载资源
5. 浏览器解析HTML生成DOM TREE，其次根据CSS生成CSS RULE TREE，而JS可以操作DOM API操作DOM

## ES5和ES6继承都区别，除了写法
+ Class声明内部会启用严格模式
+ Class都所有方法（包括静态方法和实例方法）都是不可枚举的
+ Class的所有方法都没有原型对象protptype，不能使用new调用
+ Class内部无法重写类名
+ ES5和ES6子类this生成顺序不同
> ES5的继承先生出子类实例再调用父类的构造函数修饰子类实例，ES6的继承先生成父类实例，再调用子类的构造函数修饰父类实例。这个差异使得ES6可以继承内置对象。因为this的生成顺序不同，所以需要在constructor中，需要使用super()。
